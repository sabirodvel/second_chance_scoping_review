---
title: "Data Viz for March 27th Webinar"
subtitle: "Activity Report"
author: "VALERA Camille Beatrice"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: cosmo
    toc: yes
    toc_float: yes
    css: !expr here::here("scripts/toc_custom.css")
editor_options: 
  chunk_output_type: inline
  markdown: 
    wrap: none
---

```{r global_chunk options, include = F}
knitr::opts_chunk$set(echo = F, message = F, warning = F)
```

```{r initial_setup}
if(!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, 
               here, 
               janitor, 
               reactable, 
               sf, 
               rnaturalearth, 
               reactable,
               countrycode,
               plotly, 
               ggrepel,
               treemap, #package to create treemap
               RRColorBrewer,
               patchwork
               )
```

```{r dataset_load}
included_studies_mar10 <- read_csv(here("data/included_studies_march_10.csv"))
extracted_studies_mar10 <- read_csv(here("data/extracted_studies_march_10.csv"))
```

```{r choropleth cleaning country names, include = F}
#Filter dataset to keep only rows where Reviewer Name is "Consensus"
filtered_consensus <- extracted_studies_mar10 %>%
  filter(`Reviewer Name` == "Consensus") %>%
  distinct(`Covidence #`, .keep_all = TRUE)

unique(filtered_consensus$"Country")

# Build a vector of valid country names using the countrycode package
valid_countries <- unique(c(
  countrycode::codelist$country.name.en,   # Standard country names
  countrycode::codelist$country.name.en.regex  # Alternative names
))

# Function to extract country names from mixed text.
# If no valid country is found, it returns the original text (trimmed).
extract_countries <- function(text) {
  if (is.na(text) || text == "") return(text)  # Instead of NA, return the original text
  
# Split the countries by common delimiters (commas, semicolons, parentheses, colons)
split_countries <- unlist(str_split(text, "[;,():]"))
split_countries <- str_trim(split_countries)  # Remove extra whitespace
  
# Filter counrties that are recognized as valid country names
extracted <- split_countries[split_countries %in% valid_countries]
  
# If at least one valid country is found, return unique valid names.
# Otherwise, return the original text (preserving regional responses)
  if (length(extracted) > 0) {
    return(unique(extracted))
  } else {
    return(text)
  }
}

# Apply the extraction function to the main dataframe without dropping other columns.
# This keeps your "Covidence #" and other columns intact.
cleaned_country_data <- filtered_consensus %>%
  mutate(Country = lapply(Country, extract_countries)) %>%  # Process each cell in Country column
  unnest(Country)  # Expand list-column so each country is its own row
```


# Preliminary Findings

## Research Distribution & Trends

```{r publications over time}
publications_over_time <- included_studies_mar10 %>%
  group_by(`Published Year`) %>%
  summarise(Count = n()) %>%
  arrange(`Published Year`)

# Static plot
publications_years <- publications_over_time %>%
  ggplot(aes(x = `Published Year`, y = Count)) +
  geom_line(color = "#1F968BFF", linewidth = 1) +
  geom_smooth(color = "darkgray", fill = "lightgray", size = 1, method = "loess") + # Add smooth line to show trend
  geom_point(color = "#440154FF", size = 2) +
  scale_x_continuous(breaks = seq(min(publications_over_time$`Published Year`), max(publications_over_time$`Published Year`), by = 5)) +  # Set x-axis in 5-year increments
  labs(
    title = "Research Output on Plastic Reconstructive Surgery in Sub-Saharan Africa",
    subtitle = "Tracking the number of studies published over time to understand growth \n of Plastic Reconstructive Surgery Research in SSA.",
    x = "Publication Year (5-year intervals)",
    y = "Number of Published Studies"
  ) +
  theme_minimal()
publications_years

# Interactive plot
# ggplotly(publications_years) 

```

```{r choropleth of study distribution}

# Process data: Count occurrences per country
country_counts <- cleaned_country_data %>% 
  count(Country, name = "study_count") %>%
  arrange(desc(study_count))  # Sort by study count

# Identify the top 5 countries with the highest study counts
top_countries <- country_counts %>% 
  slice_max(study_count, n = 5, with_ties = FALSE)

# Load African map data
africa <- ne_countries(scale = "medium", continent = "Africa", returnclass = "sf")

# Merge study data with map
africa_data <- africa %>%
  left_join(country_counts, by = c("name" = "Country"))

# Define color scale
study_fill_scale <- scale_fill_distiller(
  palette = "YlGnBu", 
  na.value = "white", 
  name = "Study Count",
  direction = 1,
  breaks = seq(0, max(country_counts$study_count), by = 2),  # Set custom breaks
  labels = seq(0, max(country_counts$study_count), by = 2)  # Set custom labels
)

# Plot the refined choropleth map
geo_distribution <- ggplot(data = africa_data) +
  geom_sf(aes(fill = study_count), color = "gray50", size = 0.3) +
  study_fill_scale +
  labs(title = "Distribution of Studies on Plastic Reconstructive Surgery in Sub-Saharan Africa",
       subtitle = "Top 10 Countries with the most studies.",
       caption = "Source: Covidence 'Data Charting' Dataset") +
  theme_minimal() +
  theme(legend.position = "top",
        axis.text = element_blank(), 
        axis.ticks = element_blank(),
        panel.grid = element_blank()
        )
geo_distribution 

```

```{r barplot of study distribution}

barplot_choro <- country_counts %>%
  arrange(desc(study_count)) %>%
  head(10) %>%
  mutate(percentage = study_count / sum(study_count) * 100) %>%
  ggplot(aes(x = reorder(Country, percentage), y = percentage, fill = percentage)) +
  geom_bar(stat = "identity") +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, "YlGnBu")) +
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            hjust = 2.5,
            vjust = 0.5,
            color = "black", 
            fontface = "bold") +  
  theme_minimal() +
  labs(title = "Share of Studies") +
  coord_flip() +
  theme(axis.text.x = element_blank(),  
        axis.ticks = element_blank(),    
        axis.title = element_blank(),
        legend.position = "none",
        panel.grid = element_blank(),)
barplot_choro 

```
```{r choropleth and bar}
combined_choro_bar <- 
  geo_distribution + inset_element(barplot_choro + theme(text = element_text(size = 8)),
                                   left = 0, bottom = 0, right = 0.5, top = 0.5 )
combined_choro_bar
```



```{r trends}
#!! Requires to run `extracted_data_cleaning` to obtain categorized pathologies !!
# Adding source code here - C.V.
source(here("scripts/extracted_data_cleaning.R"))

# Create frequency table, removing NA values directly in summarize
pathology_distribution <- categorized_general_pathology %>% 
  separate_rows(category_gen_pathology, sep = "; ") %>%
  filter(!is.na(category_gen_pathology)) %>%  # Remove NA values
  group_by(category_gen_pathology) %>% 
  summarize(n = n()) %>%
  ungroup() %>% 
  arrange(desc(n))

# Create simple treemap
treemap(pathology_distribution,
            index="category_gen_pathology",
            vSize="n",
            type="index")

# Customized treemap
data_tree <- 
  treemap(pathology_distribution,
        index = "category_gen_pathology",  # Define the category to index by
        vSize = "n",                       # Define the size based on 'n'
        vColor = "n",                      # Color based on frequency
        type = "index",                    # Type of treemap (index-based)
        palette = "Blues",                   # Custom color palette
        title = "Pathology Distribution",   # Custom title
        fontsize.labels = 10,               # Adjust label font size
        fontcolor.labels = "black",      # Label font color
        align.labels = c("center", "center"),  # Align labels in the center
        border.col = "white",              # Border color around boxes
        border.lw = 2
        )

# More complex treemap (to be further defined)
data_tree <- 
  treemap(pathology_distribution,
        index = "category_gen_pathology",  # Define the category to index by
        vSize = "n",                       # Define the size based on 'n'
        type = "index",                    # Type of treemap (index-based)
        )

data_ggplot <- data_tree[["tm"]] %>%
  as_tibble() %>%
  arrange(desc(vSize)) %>%
  mutate(
    rank = row_number(),
    xmax = x0 + w,
    ymax = y0 + h,
    label_pathology = str_glue("{category_gen_pathology}\n({vSize})")
  )

p1 <- ggplot(data_ggplot) +
  geom_rect(
    aes(
      xmin = x0,
      ymin = y0,
      xmax = xmax,
      ymax = ymax,
      fill = category_gen_pathology
    ),
    size = 0.1,
    colour = "#1E1D23",
    alpha = 0.9
  ) +
  geom_text(
    aes(x = (x0 + xmax) / 2,     # Position text in the middle horizontally
      y = (y0 + ymax) / 2,       # Position text in the middle vertically
      label = label_pathology),
    size = 3,                    # Font size of the labels
    color = "black",             # Font color
    fontface = "bold"            # Bold font
            ) +
  scale_fill_manual(values = c("Burns" = "#FF6347",
                               "Congenital Malformations" = "#FFD700",
                               "Trauma" = "#00BFFF",
                               "Infectious Conditions" = "#32CD32",
                               "Cyst, Tumor & Cancer" = "turquoise")
                    ) +  # Customize colors
  labs(title = "Pathologies") +
  theme_void() + # Remove axis and background 
  theme(legend.position = "none")

# Display the plot
p1 # Normal plot

#ggplotly(p1) # Interactive plot (to be refined if needed)

```
