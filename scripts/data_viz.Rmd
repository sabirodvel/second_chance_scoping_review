---
title: "Data Viz for March 27th Webinar"
author: "VALERA Camille Beatrice"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: cosmo
    toc: yes
    toc_float: yes
    css: !expr here::here("scripts/toc_custom.css")
editor_options: 
  chunk_output_type: inline
  markdown: 
    wrap: none
---

```{r global_chunk options, include = F}
knitr::opts_chunk$set(echo = F, message = F, warning = F)
```

```{r initial_setup}
if(!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, 
               here, 
               janitor, 
               reactable, 
               sf, 
               rnaturalearth, 
               rnaturalearthdata,
               reactable,
               countrycode,
               plotly, 
               ggrepel,
               treemap, #package to create treemap
               RColorBrewer,
               patchwork,
               ggfittext,
               stringi,
               flextable,
               knitr,
               officer,
               gt,
               forecast,
               purrr,
               scales
               )
```

```{r dataset_load, include = F}
# included_studies_mar10 <- read_csv(here("data/included_studies_march_10.csv"))
# extracted_studies_mar10 <- read_csv(here("data/extracted_studies_march_10.csv"))

final_df <- read_csv(here("data/final_df_aug_12.csv")) %>% 
  clean_names()

```

## Research Distribution & Trends

### Publications Over Time

```{r publications over time}

## ISOLATE THE YEAR OF PUBLICATION
final_df<- final_df %>%
  mutate(
    date_str = str_squish(date_of_publication),
    # accept either "YYYY" or "MM/YYYY" (with or without leading 0 on month)
    pub_year = case_when(
      str_detect(date_str, "^[0-9]{4}$") ~ as.integer(date_str), #accept YYYY format
      str_detect(date_str, "^(0?[1-9]|1[0-2])/[0-9]{4}$") ~ #for MM/YYYY formats, extract JUST the year (4 digits at the end)
        as.integer(str_extract(date_str, "[0-9]{4}$")),
      TRUE ~ NA_integer_  # everything else becomes NA for review
    )
  )

year_counts <- final_df %>%
  filter(!is.na(pub_year)) %>%
  count(pub_year, name = "n") 
  # complete(pub_year = seq(min(pub_year), max(pub_year), by = 1), fill = list(n = 0)) ##if we want ALL years


## CREATING LINE GRAPH
publications_over_time <- year_counts %>%
  ggplot(aes(x = pub_year, y = n)) +
  geom_line(color = "#1F968BFF", linewidth = 1) +
  geom_smooth(color = "darkgray", fill = "lightgray", size = 1, method = "loess") + # add smoothing line to show trend
  geom_point(color = "#440154FF", size = 2) +
  scale_x_continuous(breaks = seq(min(year_counts$pub_year), max(year_counts$pub_year), by = 5)) +  # set x-axis in 5-year increments
  scale_y_continuous(breaks = seq(0, max(year_counts$n), by = 5)) + # set y-axis in 5-year increments
  labs(
    title = "Plastic Reconstructive Surgery Reasearch in Sub-Saharan Africa",
    subtitle = "Total number of studies published yearly and overall trend",
    x = "Publication Year (5-year intervals)",
    y = "Number of Published Studies"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0, margin = margin(b = 6)))
publications_over_time

ggsave(filename = here("images/publications_over_time.png"))

# Interactive plot
# ggplotly(publications_years) 

```


### Geographic Distribution of Publications
```{r choropleth cleaning country names, include = F}

# unique(final_df$country)
# 
# # Build a vector of valid country names using the countrycode package
# valid_countries <- unique(c(
#   countrycode::codelist$country.name.en,   # Standard country names
#   countrycode::codelist$country.name.en.regex  # Alternative names
# ))
# 
# # Function to extract country names from mixed text.
# # If no valid country is found, it returns the original text (trimmed).
# extract_countries <- function(text) {
#   if (is.na(text) || text == "") return(text)  # Instead of NA, return the original text
#   
# # Split the countries by common delimiters (commas, semicolons, parentheses, colons)
# split_countries <- unlist(str_split(text, "[;,():]"))
# split_countries <- str_trim(split_countries)  # Remove extra whitespace
#   
# # Filter counrties that are recognized as valid country names
# extracted <- split_countries[split_countries %in% valid_countries]
#   
# # If at least one valid country is found, return unique valid names.
# # Otherwise, return the original text (preserving regional responses)
#   if (length(extracted) > 0) {
#     return(unique(extracted))
#   } else {
#     return(text)
#   }
# }
# 
# # Apply the extraction function to the main dataframe without dropping other columns.
# # This keeps your "Covidence #" and other columns intact.
# cleaned_country_data <- final_df %>%
#   mutate(country = lapply(country, extract_countries)) %>%  # Process each cell in Country column
#   unnest(country)  # Expand list-column so each country is its own row
```

### Greyed out African Countries

#### New Tries

```{r new_choro}

# ---- INPUT ----
# final_df <- df   # uncomment if your data frame is named df
stopifnot("country" %in% names(final_df))

# ---- MAP DATA ----
africa <- rnaturalearth::ne_countries(scale = "medium", continent = "Africa", returnclass = "sf") %>%
  st_transform(4326)

# SSA by World Bank region; fallback = Africa minus Northern Africa
if ("region_wb" %in% names(africa)) {
  ssa_sf <- africa %>% filter(region_wb == "Sub-Saharan Africa")
} else {
  ssa_sf <- africa %>% filter(region_un == "Africa", !subregion %in% "Northern Africa")
}

# Exclude South Africa from overlay (kept gray)
ssa_sf <- ssa_sf %>% filter(iso_a3 != "ZAF")
ssa_iso <- ssa_sf$iso_a3

# ---- TOKENIZE & HARMONIZE TO ISO3 ----
# separators include commas/semicolons/colons/parentheses/brackets/newlines and the word "and"
split_pattern <- "[,;:\\(\\)\\[\\]\\n]|\\band\\b|\\/"

# Custom synonyms → ISO3 (add here if you find new variants)
custom_iso <- c(
  "DRC" = "COD",
  "Democratic Republic of Congo" = "COD",
  "Democratic Republic of the Congo" = "COD",
  "Congo" = "COG",                    # Republic of the Congo
  "Ivory Coast" = "CIV",
  "Cote d'Ivoire" = "CIV",
  "Cote d’ivoire" = "CIV",
  "Cape Verde" = "CPV",
  "Cabo Verde" = "CPV",
  "Sao Tome and Principe" = "STP",
  "São Tomé and Príncipe" = "STP",
  "Somaliland" = "SOM",
  "Kenia" = "KEN",
  "Gambia" = "GMB",                  # Natural Earth uses GMB (map name may read Gambia/The Gambia)
   # Eswatini
  "Kingdom of eSwatini" = "SWZ",
  "Eswatini"            = "SWZ",
  "eSwatini"            = "SWZ",
  "Swaziland"           = "SWZ",
  # Guinea-Bissau
  "Guinea-Bissau"       = "GNB",
  "Guinea Bissau"       = "GNB",
  # Equatorial Guinea
  "Equatorial Guinea"   = "GNQ",
  "Eq. Guinea"          = "GNQ",
  "Guinea Ecuatorial"   = "GNQ",
  "Guinée équatoriale"  = "GNQ",
  # Comoros
  "Comoros"             = "COM",
  "Union of the Comoros"= "COM",
  "Union of Comoros"    = "COM",
  # Central African Republic
  "Central African Republic" = "CAF",
  "CAR"                       = "CAF",
  "République centrafricaine" = "CAF",
  # Namibia (usually maps already, but harmless)
  "Namibia"              = "NAM",
  # Somaliland — choose ONE policy below (A or B)
  # A) TREAT AS SOMALIA (recommended unless you want it separate):
  # "Somaliland"           = "SOM"
  # B) If you want Somaliland colored separately instead, use:
  "Somaliland"         = "SOL"
)

normalize_token <- function(x) {
  x %>%
    stringr::str_replace_all("[\u2018\u2019\u201C\u201D]", "'") %>%  # curly quotes → straight
    stringr::str_replace_all("–|—", "-") %>%
    stringr::str_squish()
}

tokens <- final_df %>%
  transmute(raw = country) %>%
  filter(!is.na(raw), raw != "") %>%
  mutate(raw = stringr::str_replace_all(raw, split_pattern, ",")) %>%
  mutate(parts = stringr::str_split(raw, ",")) %>%
  select(parts) %>%
  unnest(parts) %>%
  transmute(token = normalize_token(parts)) %>%
  filter(token != "") %>%
  # Drop obvious non-country phrases
  # filter(!stringr::str_detect(tolower(token), paste(c(
  #   "sub-?saharan africa","africa","global","world","regional","overview",
  #   "east(ern)?","west(ern)?","central","southern","northern",
  #   "middle east","americas","eastern europe","west pacific","sea",
  #   "lmi?cs?","low( |-)?and( |-)?middle","multi-?country","including",
  #   "focus on","primarily","countries","\\d+\\s*countries"
  # ), collapse = "|"))) %>%
  # First hit custom synonyms; otherwise let countrycode guess
  mutate(
    iso3 = dplyr::recode(token, !!!custom_iso, .default = NA_character_),
    iso3 = ifelse(is.na(iso3),
                  countrycode(token, origin = "country.name", destination = "iso3c", warn = FALSE),
                  iso3)
  )

# ---- DIAGNOSTICS: what didn't map? ----
unmatched <- tokens %>% filter(is.na(iso3)) %>% distinct(token) %>% arrange(token)
if (nrow(unmatched)) {
  message("Unmatched tokens (add to custom_iso if they are countries):")
  print(unmatched)
}

# Keep only tokens that map to real African ISO codes
africa_iso <- africa$iso_a3
tokens_africa <- tokens %>% filter(!is.na(iso3), iso3 %in% africa_iso)

# ---- COUNT STUDIES (SSA only, South Africa excluded) ----
country_counts <- tokens_africa %>%
  filter(iso3 %in% ssa_iso) %>%
  count(iso3, name = "study_count") %>%
  arrange(desc(study_count))

# Who in SSA got zero / never mentioned? (useful to understand "missing countries")
ssa_missing <- setdiff(ssa_iso, country_counts$iso3)
if (length(ssa_missing)) {
  message("SSA countries present in the map but with 0 mentions in your data (will be white):")
  print(ssa_sf %>% st_drop_geometry() %>% filter(iso_a3 %in% ssa_missing) %>% pull(name_long))
}

# ---- BARPLOT (labels via map names) ----
labels_lookup <- africa %>% st_drop_geometry() %>% select(iso_a3, name_long)
bar_df <- country_counts %>% left_join(labels_lookup, by = c("iso3" = "iso_a3"))

# after you create `country_counts` and `labels_lookup` -----------------------

total_n <- sum(country_counts$study_count, na.rm = TRUE)

bar_df_top10 <- country_counts %>%
  arrange(desc(study_count), iso3) %>%
  slice_head(n = 10) %>%
  left_join(labels_lookup, by = c("iso3" = "iso_a3")) %>%
  mutate(
    percentage  = 100 * study_count / total_n,
    pct_label   = sprintf("%.1f%%", percentage),
    # choose label color based on how dark the bar will be
    label_color = if_else(percentage >= 8, "white", "black")  # tweak threshold if needed
  )

barplot_choro <- bar_df_top10 %>%
  ggplot(aes(x = fct_reorder(name_long, study_count),  # order by value
             y = percentage, fill = percentage)) +
  geom_col(width = 0.8) +
  # place text just inside the right edge; color varies by bar brightness
  geom_text(aes(label = pct_label, color = label_color),
            hjust = 0.98, vjust = 0.5, size = 3.2, fontface = "bold") +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(9, "YlGnBu")) +
  scale_color_identity() +  # use the colors already in the data
  coord_flip(clip = "off") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.02))) +
  labs(title = "Top 10 Contributors to Total Studies") +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks  = element_blank(),
    axis.title  = element_blank(),
    legend.position = "none",
    panel.grid  = element_blank(),
    plot.title.position = "plot",                 # <-- anchor to plot left edge
    plot.title = element_text(size = 12, face = "bold", hjust = 0, margin = margin(b = 6)),
    plot.margin = margin(t = 8, r = 10, b = 8, l = 2)  # <-- small left margin
  )

ggsave(filename = here("images/barplot_choro.png"))

# ---- JOIN COUNTS TO SSA POLYGONS (by ISO3) ----
ssa_joined <- ssa_sf %>%
  left_join(country_counts, by = c("iso_a3" = "iso3"))

# ---- CHOROPLETH ----
geo_distribution <- ggplot() +
  geom_sf(data = africa, fill = "grey85", color = "black", linewidth = 0.2) +               # base (all Africa)
  geom_sf(data = ssa_joined, aes(fill = study_count), color = "black", linewidth = 0.2) +   # SSA overlay (South Africa excluded)
  scale_fill_distiller(
    palette = "YlGnBu", direction = 1, name = "Study count",
    na.value = "white"
  ) +
  labs(
    title    = "Geographic Distribution of Research on Plastic Reconstructive Surgery in Sub-Saharan Africa",
    subtitle = "Countries outside SSA (and South Africa) are shown in gray.",
    caption  = "Source: Covidence 'Data Charting' dataset \n (*Note: Multi-country records are split and counted for each SSA country mentioned.)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold")
  )

ggsave(filename = here("images/geo_distribution.png"))


combined_choro_bar <-
  geo_distribution +
  inset_element(barplot_choro,
                left = 0.04,
                bottom = 0.10,
                right = 0.50,
                top = 0.52)

combined_choro_bar

ggsave(filename = here::here("images/combined_choro_bar.png"),
       plot = combined_choro_bar, height = 10, width = 13, bg = "white")
```

# Study Characteristics

## Table
```{r study characteristics}
# Adding source code here
source(here("scripts/extracted_data_cleaning.R"))

# Section one (header)
.build_section <- function(df, var, section_label, digits = 1,
                           include_na_row = FALSE, na_label = "Not reported/applicable") {
  v <- df[[var]]

  # normalize to character; treat blanks as NA
  v_chr <- if (is.factor(v)) as.character(v) else as.character(v)
  v_chr <- ifelse(str_trim(v_chr) == "", NA_character_, v_chr)

  # denominator: non-missing values in this section
  denom <- sum(!is.na(v_chr))

  # counts for non-missing
  items <- tibble(value = v_chr) |>
    filter(!is.na(value)) |>
    count(value, name = "n") |>
    arrange(desc(n), value) |>
    mutate(
      pct = n / denom,
      display = sprintf("%s (%s)", n, percent(pct, accuracy = 10^-digits)),
      row_type = "item",
      label = as.character(value)
    ) |>
    select(row_type, label, display)

  # optional NA row (excluded from denominator)
  if (include_na_row && any(is.na(v_chr))) {
    na_n <- sum(is.na(v_chr))
    items <- bind_rows(
      items,
      tibble(
        row_type = "item",
        label = na_label,
        display = sprintf("%s (%s)", na_n, percent(na_n / (denom + na_n), accuracy = 10^-digits))
      )
    )
  }

  # section header row
  header <- tibble(
    row_type = "section",
    label    = sprintf("%s, n (%%)", section_label),
    display  = sprintf("N = %s studies", comma(denom))
  )

  bind_rows(header, items)
}

# ----- Build the whole profile table 
make_profile_table_gt <- function(
  df,
  sections = c(
    category_study_design = "Study design",
    source_type           = "Source of data",
    setting_level         = "Study setting",
    age_group             = "Patients (age groups)",
    affiliation_region    = "Author affiliation region"
  ),
  digits = 1,
  include_na_row = FALSE,      # set TRUE if you want an explicit NA row per section
  title = "Study demographics",# table title (left)
  overall_n_right = TRUE       # show overall N on the far right of the table title
) {
  # assemble all sections (stacked)
  body <- map2_dfr(names(sections), unname(sections), ~
    .build_section(df, var = .x, section_label = .y, digits = digits, include_na_row = include_na_row)
  )

  # little helper for visual indent
  body <- body %>%
    mutate(
      Label = ifelse(row_type == "item", paste0("  ", label), label),
      `n (%)` = display
    ) %>%
    select(Label, `n (%)`, row_type)

  # overall N (optional, in the title area)
  overall_tag <- if (overall_n_right) paste0("N = ", scales::comma(nrow(df)), " studies") else NULL

  gt_tbl <- body |>
    gt() |>
    cols_hide(columns = row_type) |>
    tab_header(
      title = md(title),
      subtitle = overall_tag
    ) |>
    # style section header rows
    tab_style(
      style = list(cell_text(weight = "bold")),
      locations = cells_body(rows = row_type == "section", columns = "Label")
    ) |>
    tab_style(
      style = list(cell_text(weight = "bold"), cell_text(align = "right")),
      locations = cells_body(rows = row_type == "section", columns = "n (%)")
    ) |>
    # add subtle indentation to item rows
    tab_style(
      style = cell_text(indent = px(12)),
      locations = cells_body(rows = row_type == "item", columns = "Label")
    ) |>
    # thin row separators between sections
    tab_options(
      table.font.size = px(13),
      data_row.padding = px(6),
      table.border.top.color = "grey70",
      table.border.top.width = px(1),
      table.border.bottom.color = "grey70",
      table.border.bottom.width = px(1)
    ) |>
    # draw a light rule above each new section
    tab_style(
      style = list(cell_borders(sides = "top", color = "grey85", weight = px(1))),
      locations = cells_body(rows = row_type == "section")
    ) |>
    cols_label(Label = md(""), `n (%)` = md("")) |>
    fmt_markdown(columns = everything())

  gt_tbl
}

# Make table using gt 
gt_table <- make_profile_table_gt(
  categorized_final,
  sections = c(
    setting_level      = "Study setting",
    # add more or reorder as you like:
    category_study_design = "Study design",
    source_type           = "Source of data",
    age_group             = "Patients (age groups)",
    affiliation_region    = "Author affiliation region"
  ),
  digits = 1,
  include_na_row = FALSE,
  title = "Study Characteristics",
  overall_n_right = TRUE
)
gt_table

# # Save Table
gtsave(gt_table, here("images/gt_study_characteristics.png"))

```


# Pathologies

## General Pathologies

### Table

```{r distribution of general pathologies}
# Adding source code here
source(here("scripts/extracted_data_cleaning.R"))

# Absolute frequency
pathology_distribution_abs <- categorized_general_pathology %>% 
  separate_rows(category_gen_pathology, sep = "; ") %>%
  filter(!is.na(category_gen_pathology)) %>%
  group_by(category_gen_pathology) %>%
  summarise(
    n = n_distinct(covidence_number),  # unique studies mentioning category
    percentage = round(100 * n_distinct(covidence_number) / nrow(categorized_general_pathology), 2),
    .groups = "drop"
  ) %>% 
  arrange(desc(n)) 

# # Weighted frequency
# pathology_distribution_weighted <- categorized_general_pathology %>%
#   separate_rows(category_gen_pathology, sep = "; ") %>%
#   filter(!is.na(category_gen_pathology)) %>%
#   distinct(covidence_number, category_gen_pathology, .keep_all = TRUE) %>%
#   group_by(covidence_number) %>%
#   mutate(num_categories = n(),
#          weight = 1 / num_categories) %>%
#   ungroup() %>%
#   group_by(category_gen_pathology) %>%
#   summarise(
#     weighted_n = round(sum(weight),2),
#     percentage_weighted = round(100 * sum(weight) / nrow(categorized_general_pathology), 2),
#     .groups = "drop"
#   )
# 
# # Merge absolute and weighted into one table
# pathology_distribution_merged <- pathology_distribution_abs %>%
#   full_join(pathology_distribution_weighted, by = "category_gen_pathology") %>%
#   arrange(desc(n))  # sort by absolute n (optional)

# pathology_distribution_merged

# Turn into flextable 
# ft <- flextable(pathology_distribution_abs)
# ft <- autofit(ft)

# # Save as Word document
# doc <- read_docx() %>%
#   body_add_flextable(ft) %>%
#   print(target = "pathology_distribution_abs.docx")

# Turn into gt 
gt <- pathology_distribution_abs %>%
  gt() %>%
  tab_header(
    title = "Distribution of Studies by Pathology Category"
  ) %>%
  cols_label(
    category_gen_pathology = "Pathology Category",
    n = "N",
    percentage = "%"
  ) %>%
  fmt_number(
    columns = percentage,
    decimals = 2
  ) %>% 
  cols_align(
    align = "center",
    columns = c(n, percentage)
  ) #%>% 
  # tab_footnote(footnote = "One study can be categorized into more than one pathology category")

gt

# # Save Table
gtsave(gt, here("images/gt_general_pathology.png"))

```

### Treemap

```{r treemap of general pathologies prep, include = F}
# Create simple treemap
treemap(pathology_distribution,
            index="category_gen_pathology",
            vSize="n",
            type="index")

# Customized treemap
data_tree <- treemap(pathology_distribution,
        index = "category_gen_pathology",  # Define the category to index by
        vSize = "n",                       # Define the size based on 'n'
        type = "index",                    # Type of treemap (index-based)
        # palette = "YlGnBu",                 # Custom color palette
        # title = "Pathology Distribution",   # Custom title
        # fontsize.labels = 10,               # Adjust label font size
        # fontcolor.labels = "black",      # Label font color
        # align.labels = c("center", "center"),  # Align labels in the center
        # border.col = "white",              # Border color around boxes
        # border.lw = 2
        )

# More refined treemap
data_ggplot <- data_tree[["tm"]] %>%
  as_tibble() %>%
  arrange(desc(vSize)) %>%
  mutate(
    rank = row_number(),
    xmax = x0 + w,
    ymax = y0 + h,
    label_pathology = str_glue("{category_gen_pathology}\n(n={vSize})")
  )

p1 <- 
  ggplot(data_ggplot) +
  geom_rect(aes(xmin = x0,
                ymin = y0,
                xmax = xmax,
                ymax = ymax,
                fill = category_gen_pathology),
            size = 2,
            colour = "white",
            alpha = 0.9) +
  geom_fit_text(aes(xmin = x0,
                    xmax = xmax,
                    ymin = y0,
                    ymax = ymax,
                    label = label_pathology),
                color = ifelse(
                  data_ggplot$category_gen_pathology == "Trauma", "white", "black"),
                min.size = 1,   # Minimum font size to avoid tiny text
                reflow = TRUE,   # Wrap text to fit the box
                ) +
  scale_fill_brewer(palette = "YlGnBu",
                    direction = 1) +  
  labs(title = "Distribution of Pathologies Requiring Reconstructive Surgery in Sub-Saharan Africa") +
  theme_void() +
  theme(legend.position = "none")  

# Display plot
p1

# Save treemap
# ggsave(filename = here("images/general_treemap.png"))

#ggplotly(p1) # Interactive plot (to be refined if needed)
```

## Specific Pathologies

### Table

```{r}
# Create frequency table 
specific_pathology_distribution <- categorized_combined_pathology %>%
  filter(!is.na(category_specific_pathology)) %>%  # Remove NA values
  separate_rows(category_specific_pathology, sep = "; ") %>%
  group_by(category_specific_pathology) %>% 
  summarize(n = n(),
            percentage = 
              round(100 * n() / nrow(categorized_combined_pathology), 2)) %>%
  ungroup() %>% 
  arrange(desc(n))

# # Turn to flextable
# ft_1 <- flextable(specific_pathology_distribution)
# ft_1 <- autofit(ft_1)

# Save as Word Doc
# doc <- read_docx() %>%
#   body_add_flextable(ft_1) %>%
#   print(target = "specific_pathology_distribution.docx")
```


### gt Table

```{r}
mapped_df <- categorized_final %>%
  filter(!is.na(category_specific_pathology)) %>% 
  separate_rows(category_specific_pathology, sep = ";") %>%
  mutate(
    category_specific_pathology = str_trim(category_specific_pathology),
    mapped_pathology = case_when(
      # Burns
      category_specific_pathology %in% c("Acute Burns", "Post-Burn Contractures & Scars") ~ "Burns",
      
      # Congenital Malformations
      category_specific_pathology %in% c(
        "Cleft Lip & Palate", "Clubfoot", 
        "Other Malformations", "Polydactyly & Syndactyly"
      ) ~ "Congenital Malformations",
      
      # Trauma
      category_specific_pathology %in% c(
        "Severe Injuries", "Soft Tissue Injuries", "Ulcers", 
        "Open Fractures", "Road Traffic Injuries", "Polytrauma", 
        "Scars", "General Fractures"
      ) ~ "Trauma",
      
      # Neoplastic Conditions
      category_specific_pathology %in% c("Other Neoplasms", "Cancer") ~ "Neoplastic Conditions",
      
      # Infectious Conditions
      category_specific_pathology %in% c("Noma", "Other Infections", "Buruli Ulcer", 
                                        "Necrotizing Fasciitis") ~ "Infectious Conditions",
      
      # Catch-all for anything else
      TRUE ~ "Other"
    )
  ) %>% 
  select(
    covidence_number,
    general_category_of_pathology,
    specific_pathology,
    category_specific_pathology,
    mapped_pathology
  )

# Reorder mapped_pathology as a factor BEFORE summarising
mapped_df <- mapped_df %>%
  mutate(mapped_pathology = factor(
    mapped_pathology,
    levels = c(
      "Trauma",
      "Burns",
      "Congenital Malformations",
      "Infectious Conditions",
      "Neoplastic Conditions",
      "Other"
    )
  ))

summary_mapped_pathology <- mapped_df %>%
  group_by(mapped_pathology, category_specific_pathology) %>%
  summarise(N = n(), .groups = "drop") %>%
  group_by(mapped_pathology) %>%               # group again for pct_domain
  mutate(pct_domain = round(100 * N / sum(N), 2)) %>%
  ungroup() %>%
  mutate(pct_overall = round(100 * N / nrow(mapped_df), 2)) %>%  # overall %
  arrange(mapped_pathology, desc(N))

# # Join absolute counts for label only
# summary_mapped_pathology <- summary_mapped_pathology %>%
#   left_join(
#     pathology_distribution_abs %>% 
#       rename(mapped_pathology = category_gen_pathology, group_N = n),
#     by = "mapped_pathology"
#   ) %>%
#   mutate(
#     mapped_label = paste0(mapped_pathology, " (N* = ", group_N, ")")
#   ) %>%
#   select(-c(group_N, mapped_pathology, percentage))  # remove group_N from final table

# Build gt table using mapped_label as groupname_col
gt_summary <- summary_mapped_pathology %>% 
  gt(
    groupname_col = "mapped_pathology",
    rowname_col   = "category_specific_pathology"
  ) %>% 
  cols_label(
    N = "N",
    pct_domain = "% within domain",
    pct_overall = "% overall"
  ) %>% 
  fmt_number(
    columns = N,
    decimals = 0
  ) %>% 
  tab_options(
    table.font.size = px(13),
    data_row.padding = px(6),
    row_group.as_column = FALSE
  ) %>% 
  tab_header(
    title = md("Pathologies Requiring Plastic Reconstructive Surgery"),
    subtitle = "Counts and percentage of specific pathologies and category (% within the specific domain, and % overall included literature)"
  ) %>% 
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_row_groups()
  ) %>% 
  cols_align(
    align = "center",
    columns = c(N, pct_domain, pct_overall)
  )

gt_summary

# # Save Table
gtsave(gt_summary, here("images/gt_specific_pathology.png"))

# # Convert to flextable
# ft <- flextable(summary_mapped_pathology)
# 
# # Optional: format columns
# ft <- colformat_num(ft, j = "N", digits = 0)

```

### Treemap

```{r treemap subgroup}
# Reorganize categories for treemap
specific_pathology_distribution %>% 
  mutate(category_gen_pathology =
           case_when(category_specific_pathology == "Cleft & Craniofacial" |
                       category_specific_pathology == "Limb Deformities"
                     ~ "Congenital Malformations",
                     category_specific_pathology == "Contractures" |
                      category_specific_pathology == "Acute Burns" |
                       category_specific_pathology == "Burn Scars"
                      ~ "Burns",
                     category_specific_pathology == "Severe Injuries" |
                       category_specific_pathology == "Soft Tissue Injuries"
                     ~ "Trauma",
                     category_specific_pathology == "Noma" |
                      category_specific_pathology == "Other Infections"
                     ~ "Infectious Conditions",
                     category_specific_pathology == "Cancer" |
                       category_specific_pathology == "Other Neoplasms"
                     ~ "Neoplasms"))


# Create the treemap plot
# data_tree_2 <- treemap(specific_pathology_distribution,
#         index = c("category_gen_pathology", "category_specific_pathology"),
#         vSize = "n",                       
#         type = "index",                    
#         palette = "YlGnBu",
#         bg.labels = rgb(0.5, 0.5, 0, alpha = 0.2),  # Make background of labels transparent
#         align.labels = list(
#               c("left", "top"),  # Alignment for general group
#               c("center", "center")  # Alignment for specific pathology
#         ),
#         fontsize.labels = c(10,9),  # Adjust label font size
#         fontcolor.labels = c("white", "white"),
#         border.col = "white",  # Border color for all boxes
#         border.lwds = c(4, 2)
# )
```

# Surgeries

## Lollipop Bar Graph

```{r lollipop surgeries}
# Create the lollipop plot
lollipop <- 
  ggplot(surgery_distribution, aes(x = reorder(category_surgery, n), y = n)) +
  geom_segment(aes(xend = category_surgery, yend = 0), color = "gray") +  # Line segment
  geom_point(size = 4, color = "#238AB0") +  # Circular lollipop head
  geom_text(aes(label = n), vjust = -1.5, size = 3) +
  coord_flip() +  # Flip axes for better readability
  labs(title = "Distribution of Categorized Surgical Procedures",
       x = "Surgical Procedures",
       y = "Number") +
  scale_y_continuous(breaks = seq(0, 140, 20)) +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),  # Remove minor grid lines
  )

# Highlight procedures
# lollipop_highlight <- 
#   ggplot(surgery_distribution, aes(x = reorder(category_surgery, n), y = n)) +
#   geom_segment(aes(xend = category_surgery, yend = 0), 
#                linewidth = if_else(surgery_distribution$category_surgery == "Soft Tissue & Skin Procedures", 1, 0.5),
#                color = if_else(surgery_distribution$category_surgery == "Soft Tissue & Skin Procedures", "#264C9F", "gray")) +  # Line segment
#   geom_point(size = if_else(surgery_distribution$category_surgery == "Soft Tissue & Skin Procedures", 4, 2), 
#              color = if_else(surgery_distribution$category_surgery == "Soft Tissue & Skin Procedures", "#264C9F", "#238AB0")) +
#   coord_flip() +  # Flip axes for better readability
#   labs(title = "Distribution of Categorized Surgical Procedures",
#        x = "Surgical Procedures",
#        y = "Count") +
#   scale_y_continuous(breaks = seq(0, 15, 2)) +
#   theme_minimal()

# Save image
# ggsave(filename = here("images/surgeries_lollipop_annotated.png"), bg = "white", plot = lollipop, width = 7, height = 4, dpi = 300)
```

# Surgical Capacity

## Tables
```{r}
# # Turn to flextable
ft_3 <- flextable(categorized_assessment_tool)
ft_3 <- autofit(ft_3)

# Save as Word Doc
doc <- read_docx() %>%
  body_add_flextable(ft_3) %>%
  print(target = "assessment_tool_capacity.docx")

# Turn to gt table
gt_3 <- categorized_assessment_tool %>%
  gt() %>%
  cols_label(
    study_id  = "Study",
    title_3   = "Title",
    country   = "Country",
    tool_used = "Type of Surgical Assessment Tool"
  ) %>%
  tab_header(
    title = "List of Studies Using Surgical Capacity Tools"
  ) %>%
  cols_width(
    study_id ~ px(150),       # wider Study column
    title_3 ~ px(300),        # make Title column much wider
    country ~ px(200),        # widen Country
    tool_used ~ px(300)       # widen Tool Used
  )

# # Save Table
gtsave(gt_3, here("images/gt_surgical_tools.png"))

```

# Barriers

## Barriers to Surgical/Reconstructive Surgical 

```{r barriers cleaning, include = F}

barriers_df <- final_df %>%
  select(covidence_number,
         `Health System Barrier`,
         `Financial  Barrier`,
         `Geograhic/Accessibility Barrier`,
         `Sociocultural Barrier`,
         `Patient-Related  Barrier`,
         `Policy/Governance  Barrier`,
         `Education/Training Barrier`,
         `Other Barrier`)

#Transform multiple responses into separate rows
barriers_clean <- filtered_barriers %>%
  pivot_longer(cols = -`Covidence #`,
               names_to = "Barrier_Type", 
               values_to = "Response") %>%
  filter(!is.na(Response) & Response != "") %>% 
  mutate(Response = str_split(Response, ",|;")) %>%
  unnest(Response) %>%
  mutate(Response = str_trim(Response) %>%
           str_to_lower()
         )
```

```{r barriers response management OG}

# Manual mapping for each response category within Barrier_Type
mapping_list <- list(
   "Education/Training Barrier" = c(
     "lack of trained staff" = "training gaps",
     "surgeon training gaps" = "training gaps",
     "training gaps" = "training gaps",
     "lack of training" = "training gaps",
     "training program in plastic surgery" = "training gaps",
     "educated staff" = "training gaps",
     "uneducated" = "training gaps",
     "health illiteracy" = "training gaps",
     "misrepresentation from health workers" = "training gaps",
     "not enough maxillofacial surgeon" = "training gaps"
  ),
  "Financial  Barrier" = c(
    "indirect cost" = "indirect costs",
    "transportation costs" = "indirect costs",
    "direct medical costs" = "direct costs",
    "out-of-pocket costs" = "direct costs",
    "service costs" = "direct costs",
    "financial-based delays in surgical care" = "direct costs",
    "low socio‐economic status" = "direct costs",
    "high cost of materials" = "direct costs",
    "insurance related barriers" = "direct costs"
    
  ),
  "Geograhic/Accessibility Barrier" = c(
    "distance" = "physical distance",
    "travel time" = "physical distance",
    "transportation" = "transportation issues",
    "transportations issues" = "transportation issues",
    "direct medical costs" = "transportation issues",
    "travel" = "physical distance",
    "limited number of facilities providing burn care services" = "rural vs. urban disparities",
    "poor access" = "rural vs. urban disparities",
    "referral vs. district hospital disparities"= "rural vs. urban disparities"
  ),
  "Health System Barrier" = c(
    "anaesthesia" = "infrastructure limitations",
    "blood bank" = "infrastructure limitations",
    "electricity" = "infrastructure limitations",
    "health system inefficiencies" = "health system inefficiencies",
    "health system inneficiencies" = "health system inefficiencies",
    "human resource shortage" = "human resource shortages",
    "human resource shortages" = "human resource shortages",
    "human resource limitation" = "human resource shortages",
    "shortage of pediatric surgeons" = "human resource shortages",
    "inpatient capacity" = "infrastructure limitations",
    "limited infrastructure" = "infrastructure limitations",
    "limited surgical infrastructure" = "infrastructure limitations",
    "number of plastic surgeons" = "human resource shortages",
    "operating rooms" = "infrastructure limitations",
    "referral system" = "referral system issues",
    "referral system issues" = "referral system issues",
    "specialized care" = "infrastructure limitations",
    "treatment delay" = "health system inefficiencies",
    "limited access to physiotherapy and post post-operative rehabilitation" = "health system inefficiencies",
    "low government support for burn patientss" = "health system inefficiencies",
    "access to post-operation care" = "health system inefficiencies"
  ),
  
  "Patient-Related  Barrier" = c(
    "appraisal delay" = "perceived need for surgery",
    "fear" = "fear",
    "fear of hospitals" = "fear",
    "late presentation" = "perceived need for surgery",
    "literacy" = "perceived need for surgery",
    "perceived need" = "perceived need for surgery",
    "perceived need for surgery" = "perceived need for surgery",
    "perceived-need for surgery" = "perceived need for surgery",
    "awareness" = "lack of service awareness",
    "commobidities" = "comorbidities",
    "education" = "lack of service awareness",
    "lack of awareness of available treatment options." = "lack of service awareness",
    "lack of service awareness" = "lack of service awareness",
    "time" = "perceived need for surgery"
  ),
   "Sociocultural Barrier" = c(
    "awareness" = "health literacy",
    "cultural beliefs" = "stigma and cultural beliefs",
    "delayed health seeking behavior" = "health literacy",
    "health literacy" = "health literacy",
    "medical literacy" = "health literacy",
    "religious belief" = "stigma and cultural beliefs",
    "stigma and cultural beliefs" = "stigma and cultural beliefs",
    "traditional medicine" = "stigma and cultural beliefs",
    "sociocultural handicaps"= "stigma and cultural beliefs",
    "traditional healers" = "stigma and cultural beliefs"
  ),
  "Policy/Governance  Barrier" = c(
    "iinadequate investment in surgical training" = "funding gaps",
    "lack of awareness" = "regulatory issues",
    "lack of strategy" = "regulatory issues"
  )
)

# helper to assign grouped responses via exact pattern matching
assign_group <- function(responses, mapping) {
  grouped <- responses
  for (pattern in names(mapping)) {
    grouped <- if_else(
      str_detect(responses, fixed(pattern, ignore_case = TRUE)),
      mapping[[pattern]],
      grouped
    )
  }
  grouped
}

# 
# # Apply grouping per Barrier_Type if mapping exists; otherwise keep the original response.
# barriers_clean_2 <- barriers_clean %>%
#   group_by(Barrier_Type) %>%
#   mutate(Grouped_Response = if (Barrier_Type[1] %in% names(mapping_list)) {
#       assign_group(Response, mapping_list[[Barrier_Type[1]]])
#     } else Response) %>%
#   ungroup()
# 
# # Count occurrences
# barrier_counts <- barriers_clean_2 %>%
#   count(Barrier_Type, Grouped_Response)
# 
# # Create an extended palette similar to YlGnBu
# unique_groups <- unique(barrier_counts$Grouped_Response)
# num_groups <- length(unique_groups)
# my_palette <- colorRampPalette(brewer.pal(9, "YlGnBu"))(num_groups)

# --- 5. Apply mapping per Barrier_Type, keep original if no mapping defined ---
barriers_clean_2 <- barriers_clean %>%
  group_by(Barrier_Type) %>%
  mutate(
    Grouped_Response = if (Barrier_Type[1] %in% names(mapping_list)) {
      assign_group(Response, mapping_list[[Barrier_Type[1]]])
    } else {
      Response
    }
  ) %>%
  ungroup()

# --- 6. Count occurrences (initial, if you want to inspect) ---
barrier_counts <- barriers_clean_2 %>%
  count(Barrier_Type, Grouped_Response, name = "n")

# --- 7. Collapse *all* "Other Barrier" into one single group and re-count ---
barrier_counts2 <- barriers_clean_2 %>%
  mutate(
    Grouped_Response = if_else(
      Barrier_Type == "Other Barrier",
      "other barriers",
      Grouped_Response
    )
  ) %>%
  count(Barrier_Type, Grouped_Response, name = "n")

# --- 8. Re-order Barrier_Type factor (placing Other Barrier last) ---
combined_barrier_data <- barrier_counts2 %>%
  mutate(
    Barrier_Type = fct_relevel(Barrier_Type,
      "Health System Barrier",
      "Geograhic/Accessibility Barrier",
      "Financial  Barrier",
      "Education/Training Barrier",
      "Policy/Governance  Barrier",
      "Patient-Related  Barrier",
      "Sociocultural Barrier",
      "Other Barrier"
    )
  )

# --- 9. Build a color palette matching the number of groups ---
unique_groups <- unique(combined_barrier_data$Grouped_Response)
my_palette     <- colorRampPalette(brewer.pal(9, "YlGnBu"))(length(unique_groups))

# --- 10. Plot: stacked bar, only label segments where n > 1 ---
stackedbar_combined <- ggplot(combined_barrier_data,
                              aes(x = Barrier_Type,
                                  y = n,
                                  fill = Grouped_Response)) +
  geom_bar(stat = "identity") +
  geom_text(aes(
    label = if_else(n > 1, paste0("n = ", n), "")
  ),
  position = position_stack(vjust = 0.5),
  size = 5
  ) +
  scale_fill_manual(values = my_palette) +
  theme_minimal() +
  labs(
    title = "Barriers to Surgical Care",
    x     = "Types of Barriers",
    y     = "Number of Responses",
    fill  = "Grouped Response"
  ) +
  theme(
    axis.text.x    = element_text(angle = 45, hjust = 1, size = 12),
    axis.title     = element_text(size = 14),
    plot.title     = element_text(size = 16, face = "bold"),
    legend.position = "top",
    panel.grid     = element_blank()
  )

# --- 11. Display the plot and save to file ---
print(stackedbar_combined)
ggsave(
  filename = here("images", "barriers_to_care_may_12_collapsed.png"),
  plot     = stackedbar_combined,
  height   = 10,
  width    = 13,
  bg       = "white"
)

```

```{r barrier stacked bar OG}
# Ensure the order of Barrier_Type is as specified
combined_barrier_data <- barrier_counts %>%
  mutate(Barrier_Type = fct_relevel(Barrier_Type,
                                    "Health System Barrier", 
                                    "Geographic/Accessibility Barrier", 
                                    "Financial  Barrier", 
                                    "Education/Training Barrier", 
                                    "Policy/Governance  Barrier", 
                                    "Patient-Related  Barrier", 
                                    "Sociocultural Barrier"))

# Create the plot with counts displayed as 'n = <count>' and grouping by Barrier_Type
stackedbar_combined <- ggplot(combined_barrier_data, aes(x = Barrier_Type, y = n, fill = Grouped_Response)) +
  geom_bar(stat = "identity") +
  # Add counts with the 'n = ' prefix, centered in each segment
  geom_text(aes(label = paste("n = ", n)),
            position = position_stack(vjust = 0.5), size = 5, color = "black") +
  scale_fill_manual(values = my_palette) +
  theme_minimal() +
  labs(title = "Barriers to Surgical Care",
       x = "Types of Barriers",
       y = "Number of Responses",
       fill = "Grouped Response") +  # Change legend title to 'Grouped Response'
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),  
        axis.title = element_text(size = 14),                         
        plot.title = element_text(size = 16, face = "bold"),          
        legend.position = "top",                                      
        panel.grid = element_blank())                                 

# Display the plot
stackedbar_combined

# Save plot as image
ggsave(filename = here("images/barriers_to_care_may_12.png"), plot = stackedbar_combined, height = 10, width = 13, bg = "white")
```

```{r barriers test}
# # Define clean, non-overlapping mappings, including a combined Patient/Sociocultural list
# mapping_list <- list(
#    "Education/Training Barrier" = c(
#      "lack of trained staff" = "training gaps",
#      "surgeon training gaps" = "training gaps",
#      "training gaps" = "training gaps",
#      "lack of training" = "training gaps",
#      "training program in plastic surgery" = "training gaps",
#      "educated staff" = "training gaps",
#      "uneducated" = "training gaps",
#      "health illiteracy" = "training gaps",
#      "misrepresentation from health workers" = "training gaps",
#      "not enough maxillofacial surgeon" = "training gaps"
#   ),
#   "Financial  Barrier" = c(
#     "indirect cost" = "indirect costs",
#     "transportation costs" = "indirect costs",
#     "direct medical costs" = "direct costs",
#     "out-of-pocket costs" = "direct costs",
#     "service costs" = "direct costs",
#     "financial-based delays in surgical care" = "direct costs",
#     "low socio‐economic status" = "direct costs",
#     "high cost of materials" = "direct costs",
#     "insurance related barriers" = "direct costs"
# 
#   ),
#   "Geograhic/Accessibility Barrier" = c(
#     "distance" = "physical distance",
#     "travel time" = "physical distance",
#     "transportation" = "transportation issues",
#     "transportations issues" = "transportation issues",
#     "direct medical costs" = "transportation issues",
#     "travel" = "physical distance",
#     "limited number of facilities providing burn care services" = "rural vs. urban disparities",
#     "poor access" = "rural vs. urban disparities",
#     "referral vs. district hospital disparities"= "rural vs. urban disparities"
#   ),
#   "Health System Barrier" = c(
#     "anaesthesia" = "infrastructure limitations",
#     "blood bank" = "infrastructure limitations",
#     "electricity" = "infrastructure limitations",
#     "health system inefficiencies" = "health system inefficiencies",
#     "health system inneficiencies" = "health system inefficiencies",
#     "human resource shortage" = "human resource shortages",
#     "human resource shortages" = "human resource shortages",
#     "human resource limitation" = "human resource shortages",
#     "shortage of pediatric surgeons" = "human resource shortages",
#     "inpatient capacity" = "infrastructure limitations",
#     "limited infrastructure" = "infrastructure limitations",
#     "limited surgical infrastructure" = "infrastructure limitations",
#     "number of plastic surgeons" = "human resource shortages",
#     "operating rooms" = "infrastructure limitations",
#     "referral system" = "referral system issues",
#     "referral system issues" = "referral system issues",
#     "specialized care" = "infrastructure limitations",
#     "treatment delay" = "health system inefficiencies",
#     "limited access to physiotherapy and post post-operative rehabilitation" = "health system inefficiencies",
#     "low government support for burn patientss" = "health system inefficiencies",
#     "access to post-operation care" = "health system inefficiencies"
#   ),
#   "Patient/Sociocultural  Barrier" = c(
#     #from Patient-related barriers
#     "appraisal delay" = "perceived need for surgery",
#     "fear" = "fear",
#     "fear of hospitals" = "fear",
#     "late presentation" = "perceived need for surgery",
#     "literacy" = "perceived need for surgery",
#     "perceived need" = "perceived need for surgery",
#     "perceived need for surgery" = "perceived need for surgery",
#     "perceived-need for surgery" = "perceived need for surgery",
#     "awareness" = "lack of service awareness",
#     "commobidities" = "comorbidities",
#     "education" = "lack of service awareness",
#     "lack of awareness of available treatment options." = "lack of service awareness",
#     "lack of service awareness" = "lack of service awareness",
#     "time" = "perceived need for surgery",
#     #from Sociocultural Barriers
#     "awareness" = "health literacy",
#     "cultural beliefs" = "stigma and cultural beliefs",
#     "delayed health seeking behavior" = "health literacy",
#     "health literacy" = "health literacy",
#     "medical literacy" = "health literacy",
#     "religious belief" = "stigma and cultural beliefs",
#     "stigma and cultural beliefs" = "stigma and cultural beliefs",
#     "traditional medicine" = "stigma and cultural beliefs",
#     "sociocultural handicaps"= "stigma and cultural beliefs",
#     "traditional healers" = "stigma and cultural beliefs"
#   ),
#   "Policy/Governance  Barrier" = c(
#     "iinadequate investment in surgical training" = "funding gaps",
#     "lack of awareness" = "regulatory issues",
#     "lack of strategy" = "regulatory issues"
#   )
# )
# 
# assign_group <- function(responses, mapping) {
#   out <- responses
#   for(pat in names(mapping)) {
#     out <- if_else(
#       str_detect(responses, fixed(pat, ignore_case = TRUE)),
#       mapping[[pat]],
#       out
#     )
#   }
#   out
# }
# 
# # ------------------------------------------------------------------------------
# # 3. Map, count, collapse singletons, and re-aggregate
# #    Assumes you have a data frame `barriers_clean` with columns:
# #    - Barrier_Type (character/factor)
# #    - Response     (character)
# # ------------------------------------------------------------------------------
# counts_raw <- barriers_clean %>%
#   # normalize spacing and merge Patient-Related + Sociocultural
#   mutate(
#     Barrier_Type = str_squish(Barrier_Type),
#     Barrier_Type = case_when(
#       Barrier_Type %in% c("Patient-Related Barrier", "Sociocultural Barrier") ~
#         "Patient/Sociocultural Barrier",
#       TRUE ~ Barrier_Type
#     )
#   ) %>%
#   # apply the appropriate mapping if available
#   group_by(Barrier_Type) %>%
#   mutate(
#     Grouped_Response = if (Barrier_Type[1] %in% names(mapping_list)) {
#       assign_group(Response, mapping_list[[Barrier_Type[1]]])
#     } else {
#       Response
#     }
#   ) %>%
#   ungroup() %>%
#   # initial count by Barrier_Type + Grouped_Response
#   count(Barrier_Type, Grouped_Response)
# 
# # collapse any one-off "n == 1" into an "Other" category
# counts_collapsed <- counts_raw %>%
#   group_by(Barrier_Type) %>%
#   mutate(
#     Grouped_Response = if_else(n == 1, "Other", Grouped_Response)
#   ) %>%
#   ungroup()
# 
# # re-aggregate so that all the "Other" pieces are summed together
# barrier_counts2 <- counts_collapsed %>%
#   group_by(Barrier_Type, Grouped_Response) %>%
#   summarise(n = sum(n), .groups = "drop")
# 
# # ------------------------------------------------------------------------------
# # 4. Build a color palette and set the x-axis order
# # ------------------------------------------------------------------------------
# my_palette <- colorRampPalette(brewer.pal(9, "YlGnBu"))(
#   length(unique(barrier_counts2$Grouped_Response))
# )
# 
# barrier_plot_data <- barrier_counts2 %>%
#   mutate(
#     Barrier_Type = factor(
#       Barrier_Type,
#       levels = c(
#         "Health System Barrier",
#         "Geographic/Accessibility Barrier",
#         "Financial Barrier",
#         "Education/Training Barrier",
#         "Policy/Governance Barrier",
#         "Patient/Sociocultural Barrier"
#       )
#     )
#   )
# 
# # ------------------------------------------------------------------------------
# # 5. Create and save the stacked bar plot
# # ------------------------------------------------------------------------------
# stackedbar_combined <- ggplot(
#   barrier_plot_data,
#   aes(x = Barrier_Type, y = n, fill = Grouped_Response)
# ) +
#   geom_bar(stat = "identity") +
#   geom_text(
#     aes(label = paste0("n = ", n)),
#     position = position_stack(vjust = 0.5),
#     size = 5, color = "black"
#   ) +
#   scale_fill_manual(values = my_palette) +
#   theme_minimal() +
#   labs(
#     title = "Barriers to Surgical Care",
#     x     = "Types of Barriers",
#     y     = "Number of Responses",
#     fill  = "Grouped Response"
#   ) +
#   theme(
#     axis.text.x     = element_text(angle = 45, hjust = 1, size = 12),
#     axis.title      = element_text(size = 14),
#     plot.title      = element_text(size = 16, face = "bold"),
#     legend.position = "top",
#     panel.grid      = element_blank()
#   )
# 
# # Display the plot
# print(stackedbar_combined)
# 
# # Save the plot to disk
# ggsave(
#   filename = here("images/barriers_to_care_fixed.png"),
#   plot     = stackedbar_combined,
#   height   = 10,
#   width    = 13,
#   bg       = "white"
# )

```


# DALYs 

```{r general daly pie chart}

# Create summary data
daly_data <- pathology_daly %>% 
  separate_rows(general_category_of_pathology, sep = ";") %>%
  mutate(general_category_of_pathology = str_trim(general_category_of_pathology)) %>%
  group_by(general_category_of_pathology) %>%
  summarize(n = n()) %>%
  ungroup()

# Compute the position of labels
daly_data <- daly_data %>% 
  arrange(desc(general_category_of_pathology)) %>%
  mutate(prop = n / sum(daly_data$n) * 100) %>%
  mutate(ypos = cumsum(prop)- 0.51 * prop)

# Basic piechart
daly_piechart <- 
  ggplot(daly_data, aes(x="", y = prop, fill=general_category_of_pathology)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  theme(legend.position="none") +
  geom_text(aes(y = ypos, 
                label = str_to_title(general_category_of_pathology)),
                color = if_else(daly_data$general_category_of_pathology == 
                                  "trauma", "darkgray", "white"),
            size=5) +
  scale_fill_brewer(palette="YlGnBu",
                    direction = -1)
#Display graph
daly_piechart

# Save graph
ggsave(filename = here("images/daly_piechart.png"), plot = daly_piechart)

```


## Orofacial Clefts

```{r orofacial cleft dalys}
ssa_iso3 <- c(
  "AGO", # Angola
  "BEN", # Benin
  "BWA", # Botswana
  "BFA", # Burkina Faso
  "BDI", # Burundi
  "CPV", # Cabo Verde
  "CMR", # Cameroon
  "CAF", # Central African Republic
  "TCD", # Chad
  "COM", # Comoros
  "COG", # Congo
  "COD", # Democratic Republic of the Congo
  "DJI", # Djibouti
  "GNQ", # Equatorial Guinea
  "ERI", # Eritrea
  "SWZ", # Eswatini
  "ETH", # Ethiopia
  "GAB", # Gabon
  "GMB", # Gambia
  "GHA", # Ghana
  "GIN", # Guinea
  "GNB", # Guinea-Bissau
  "CIV", # Ivory Coast
  "KEN", # Kenya
  "LSO", # Lesotho
  "LBR", # Liberia
  "MDG", # Madagascar
  "MWI", # Malawi
  "MLI", # Mali
  "MRT", # Mauritania
  "MUS", # Mauritius
  "MOZ", # Mozambique
  "NAM", # Namibia
  "NER", # Niger
  "NGA", # Nigeria
  "RWA", # Rwanda
  "STP", # São Tomé and Príncipe
  "SEN", # Senegal
  "SYC", # Seychelles
  "SLE", # Sierra Leone
  "SOM", # Somalia
  "SSD", # South Sudan
  "SDN", # Sudan
  "TZA", # Tanzania
  "TGO", # Togo
  "UGA", # Uganda
  "ZMB", # Zambia
  "ZWE"  # Zimbabwe
)

# Load African map data
africa <- ne_countries(scale = "medium", continent = "Africa", returnclass = "sf")

# Quick clean of data
burden_orofacialcleft <- burden_orofacialcleft %>% 
  filter(!country %in%  c("Central Africa", "Saharan Africa"))

# Join data + map values
africa_burden_cleft <- left_join(africa, burden_orofacialcleft, by = c("name" = "country")) %>% 
  mutate(
    is_ssa = iso_a3 %in% ssa_iso3,  # Flag SSA countries
    # is_south_africa = country == "South Africa",  # Flag South Africa
  )

# Define color scale
study_fill_scale <- scale_fill_distiller(
  palette = "YlGnBu",
  na.value = "white",
  name = "DALYs per 100,000 people",
  direction = 1,
  breaks = seq(15, max(burden_orofacialcleft$dalys), 5),  # Set custom breaks
  labels = seq(15, max(burden_orofacialcleft$dalys), 5)  # Set custom labels
)

# Plot the refined choropleth map
geo_orofacial_dalys <- ggplot(data = africa_burden_cleft) +
  # Color SSA studies
  geom_sf(aes(fill = dalys), color = "gray50", size = 0.3) +
  # Gray out non-SSA countries
  geom_sf(data = africa_burden_cleft %>% filter(!is_ssa), 
          fill = "gray", color = "gray50", size = 0.3)+
  study_fill_scale +
  labs(title = "Burden of Orofacial Clefts in Sub-Saharan Africa",
       caption = "Source: Kantar R.S., 2023") +
  theme_minimal() +
  theme(legend.position = "top",
        axis.text = element_blank(), 
        axis.ticks = element_blank(),
        panel.grid = element_blank()
        )

# Display graph
geo_orofacial_dalys

# Save image
ggsave(filename = here("images/orofacial_cleft_dalys.png"), plot = geo_orofacial_dalys, bg = "white", height = 6)
```

## Burns

```{r dalys burns}
# Create the combined plot
burn_combined_plot <- burn_daly %>%
  ggplot(aes(x = time)) +
  
  # First line (Disability Score)
  geom_line(data = burn_daly %>% filter(score == "disability"), 
            aes(y = value), color = "#1F968BFF", linewidth = 1) +
  geom_point(data = burn_daly %>% filter(score == "disability"), 
             aes(y = value), color = "#440154FF", size = 2) +
  
  # Second line (Quality of Life Score) scaled to a secondary axis
  geom_line(data = burn_daly %>% filter(score == "quality of life"), 
            aes(y = value), color = "#92D050", linewidth = 1) +
  geom_point(data = burn_daly %>% filter(score == "quality of life"), 
             aes(y = value), color = "#482677FF", size = 2) +
  
  # X-axis settings
  scale_x_continuous(breaks = seq(0, 12, 3)) +
  
  # Y-axis settings
  scale_y_continuous(
    name = "Disability Score (WHODAS 2.0)", 
    sec.axis = sec_axis(~ ., name = "Quality of Life Score"),
    breaks = seq(0.00, 1.00, by = 0.25),
    limits = c(0,1)
  ) +
  
  labs(x = "Time (Months)") +
  theme_minimal() +
  
  # Adjust theme for better readability
  theme(
    axis.title.y.left = element_text(color = "#1F968BFF"),
    axis.title.y.right = element_text(color = "#92D050")
  )

burn_combined_plot

# Save plot
ggsave(filename = here("images/disability_qol_plot.png"), plot = burn_combined_plot, height = 4, width = 5,  bg = "white")

```


